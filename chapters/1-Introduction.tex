\section{Introduction}

\subsection{Motivation}
Weak memory specializes on research that aims to improve the results in memory modeling. Weak memory focuses on determining the relative strength of different models. This is why one of the common challenges is to show equaivalences between several models. Given two memory models \texttt{A} and \texttt{B} we might want to check if model \texttt{A} is stronger then model \texttt{B}. If that condition holds, then the consistency of the model \texttt{A} would imply the consistency of the model \texttt{B}.

Memory models and propositions about them are usually represented as expressions over relational language. However, proofs of such the propositions are typically massive and very error prone. There were several cases of incorrect result in submited and published papers. Batty et al.~\cite{batty_2016}\ suggested an incorrect fix for the semantics of SC calls in C++, which was later documented by Lahav et al.~\cite{lahav2017repairing}. Moreover Pichon-Pharabod et al.\  in 2016 suggested an incorrect proof of compilation in their paper~\cite{PichonPharabod_Sewell16}. 

Weak memory proofs are usually written in Coq~\cite{bertot2013interactive}, which is a proof assistant system. Coq helps to grant the correctness of the proof process. The underlying language of Coq is called \textit{Calculus of Inductive Constructions} (CIC). In CIC, proofs are expressed as formal mathematical objects, and the correctness of the proof is ensured by checking that the proof is consistent with the axioms and rules of logic. Coq is the standard of development in the field of weak memory, helping to unify and verify already complex proofs. 

Nevertheless, weak memory proofs, even with a use of Coq, tend to be huge and convoluted. This is why in this thesis, we are focusing on automating a specific part of weak memory proofs, namely the proofs of equaivalences between several memory models. As already mentioned, memory models are defined as relations. Let's denote \texttt{r} and \texttt{r'} the two memory models or relations over a given set \texttt{A}. Now we may consider common operations in relational language, e.g.\ transitive closure (\texttt{r*}), reflexive closure (\texttt{r?}), or composition (\texttt{r {;;} r'}). An example of a proposition we want to prove may look like this: 
\begin{center}
    \texttt{(r* {;;} r?) {;;} r? $\equiv$ r*}
\end{center}
If we were to prove this statement in Coq by hand, we would have to consequently apply multiple theorems to rewrite both sides of the equivalence relation until they are syntactically equal. In this particular example, we would have to apply thorem \texttt{rt\_cr} twice: 
\begin{center}
    \texttt{rt\_cr {:} forall (A {:} Type) (r {:} relation A), r* {;;} r? = r*}
\end{center}
After \texttt{rt\_cr} being applied to the left hand side (lhs) two times, the two sides become syntactically equal. \texttt{rt\_cr} and other theorems that help to reason about relations are provided by the Hahn library~\cite{hahn_lib}. 

The general problem discussed in this thesis is as follows: given a rewriting system, i.e.\ a set of theorems, and an equaivalence relation between two expressions, we want to find a sequence of rewrites that can be applied to both sides of the relation to make them syntactically equal. This is a wider problem than reasoning about relational expressions, thereafter the solution we propose could be adapted and used to solve other problems that involve derivability in two-sided associative calculus over given language in Coq. This thesis, in turn, focuses on applying the proposed technique to automate weak memory, where the rewriting system we use is the Hahn library. 

\subsection{Approach}
Our approach to solve equivalences is based on the technique called \textit{equality saturation} which utilizes the data structure, called an e-graph. E-graph stores an equivalence relation over terms of some language and allows to store potentially exponential amount of terms in a compact way. E-graph is a set of equaivalence classes (\textit{e-classes}) and e-class is a set of \textit{e-nodes}, which represent equivalent terms in the language. Whilst e-nodes are function symbols, associated with a list of e-classes. 

Equality saturation is a process of iteratively applying a set of rewrite rules to the e-graph until rewrites bring no more new information to the graph. That point is called saturation. The saturated e-graph represents a set of all possible terms  equivalent to the origin, that can be obtained by applying the rewrite rules to the initial term.

% TODO: Видимо добавть слов почему это просто и как это делается. Особенно не очень понятно на первый взгляд как искать доказательство. А может это и не надо понимать. 
In a saturated e-graph it becomes algorithmically easy to check if two terms are equaivalent and, moreover, to find a proof of their equivalence. Having a sequence of rewrites, we can apply them within Coq proof view. Just as we would do by hand, applying the theorems one by one.

% TODO: Заменить на Contributions? 
\subsection{Core implementation components}

We have chosen fast and lightweight \texttt{egg}~\cite{egg} rust library as an equality saturation engine for our project. \texttt{Egg} is a new and ambitious project, that has already proven its worth and was used in tools like \textit{Ruler}~\cite{ruler}. 

In Coq you can add new functionality by writing a plugin. Plugins are written in Ocaml language. We have set the communication between Ocaml and Rust using the \texttt{ocaml-rs}~\cite{ocaml_rust_ffi} foreign function interface (FFI).\@ To prove theorems in Coq, you use proof mode, which is activated when you start a proof, for example, by using the \texttt{Theorem} command. The proof state contains one or more unproven goals. Each goal consists of a conclusion, which is the statement to be proven, and a local context. When the proof is complete, you exit proof mode by using the \texttt{Qed} command. During proof mode, you use so called \textit{tactics}, to gradually transform the proof. Tactics specify how to transform the proof state of an incomplete proof and are used to eventually generate a complete proof.

Commands in Coq are similar to tactics, but accessible from outside of proof mode, e.g.\ command \texttt{Print}, which prints the given term to console. A Coq plugin typically consists of a set of commands and tactics, that are used from Coq as a front-end to the plugin. 
We have defined multiple tools inside our plugin, that are used to interact with the \texttt{egg} library: 
\begin{itemize}
    \item \texttt{Cegg solve} --- a tactic that simplifies the lhs of the equation. It takes the conclusion of the goal, retrieves the lhs of the equivalence, parses it into an s-expression\footnote{S-expressions represent tree-like data} and passes it to \texttt{egg}. \texttt{Egg} builds an e-graph $E$ for it and extracts the ``best'' term $t$ from $E$. A sequence of rewrites to achieve $t$ is passed back to Ocaml and is applied to the lhs of the equivalence inside Coq proof mode. 
    \item \texttt{Cegg solve eq} --- a tactic that tries to prove the equivalence between the lhs and rhs of the equation, using \texttt{egg}. 
    \item \texttt{Cegg config} --- a command, that allows to configure the ruleset for \texttt{egg}. It takes a user-defined list of rewrite rules and caches it for the later use in \texttt{Cegg solve} and \texttt{Cegg solve eq}.
\end{itemize}
The source code and documentation for the thesis is available at:
\begin{center}
    \href{https://github.com/K-dizzled/relations-via-egg}{\texttt{https://github.com/K-dizzled/relations-via-egg}}
\end{center}

% TODO: Добавить Outline? 